/*
问题描述
　　在某图形操作系统中,有 N 个窗口,每个窗口都是一个两边与坐标轴分别平行的矩形区域。
	窗口的边界上的点也属于该窗口。窗口之间有层次的区别,在多于一个窗口重叠的区域里,只会显示位于顶层的窗口里的内容。
　　当你点击屏幕上一个点的时候,你就选择了处于被点击位置的最顶层窗口,并且这个窗口就会被移到所有窗口的最顶层,而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口,则系统会忽略你这次点击。
　　现在我们希望你写一个程序模拟点击窗口的过程。
输入格式
　　输入的第一行有两个正整数,即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10)
　　接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。
	每行包含四个非负整数 x1, y1, x2, y2,表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 < x2,y1 2。
　　接下来 M 行每行包含两个非负整数 x, y,表示一次鼠标点击的坐标。
　　题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和　　1439。
输出格式
　　输出包括 M 行,每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口,则输出这个窗口的编号(窗口按照输入中的顺序从 1 编号到 N);
	如果没有,则输出"IGNORED"(不含双引号)。

	样例输入
3 4
0 0 4 4
1 1 5 5
2 2 6 6
1 1
0 0
4 4
0 5
	样例输出
	2
	1
	1
	IGNORED
*/
#include "iostream"
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;

int main() {
	int N, M, x1, x2, y1, y2, x, y;
	cin >> N >> M;
	vector<vector<int>> Figure;
	vector<int> temp;
	queue<int> result;
	int i = N;
	do {
		temp.clear();
		cin >> x1 >> y1 >> x2 >> y2;
		temp.push_back(x1);
		temp.push_back(y1);
		temp.push_back(x2);
		temp.push_back(y2);
		temp.push_back(N - i + 1);
		Figure.push_back(temp);
	} while (--i);

	int j = M;
	while (j--) {
		cin >> x >> y;
		i = N;
		while (i--) {
			temp = Figure[i];
			if ((x >= temp[0] && x <= temp[2]) && (y >= temp[1] && y <= temp[3])) {
				result.push(temp.back())  ;
				if (i != (N - 1))
					rotate(Figure.begin() + i, Figure.begin() + i + 1, Figure.end());
				break;
			}
		}
		if (i == -1)
			result.push(0)  ;
	}

	j = M;
	while (j--) {
		if (result.front()) {
			cout << result.front() << endl;
			result.pop();
		} else {
			cout << "IGNORED" << endl;
			result.pop();
		}

	}
	return 0;
}